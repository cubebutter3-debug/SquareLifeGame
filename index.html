<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Square Life â€” MVP</title>
<style>
  :root { --bg:#101418; --panel:#171d24; --ink:#e7eef7; --muted:#9fb3c7; --accent:#6fd3a8; --warn:#ffb35c; --bad:#ff6b6b; }
  html, body { height:100%; margin:0; background:var(--bg); color:var(--ink); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; }
  #wrap { display:grid; grid-template-columns: 1fr 360px; gap:12px; padding:12px; box-sizing:border-box; height:100%; }
  #panel, #topbar { background:var(--panel); border:1px solid #232a33; border-radius:10px; }
  #topbar { grid-column: 1 / -1; display:flex; align-items:center; gap:16px; padding:8px 12px; }
  #stats { display:flex; gap:16px; align-items:center; flex-wrap:wrap; }
  .chip { background:#0f141a; border:1px solid #202833; border-radius:8px; padding:6px 10px; font-size:14px; }
  #canvasWrap { position:relative; }
  #game { display:block; width:100%; height:auto; border:1px solid #232a33; background:#0b1015; border-radius:10px; }
  #panel { padding:12px; overflow:auto; }
  h3 { margin:8px 0 6px; font-size:16px; color:#d9e6f2; }
  .row { display:flex; gap:8px; flex-wrap:wrap; }
  button { cursor:pointer; background:#131920; color:var(--ink); border:1px solid #263041; border-radius:8px; padding:8px 10px; font-weight:600; }
  button:hover { border-color:#3b4a60; }
  button.sel { outline:2px solid var(--accent); }
  .small { font-size:12px; color:var(--muted); }
  .sep { height:1px; background:#1f2731; margin:8px 0; }
  .tag { font-size:12px; padding:2px 6px; border-radius:6px; background:#0c1218; border:1px solid #223042; }
  .good { color:var(--accent); }
  .warn { color:var(--warn); }
  .bad { color:var(--bad); }
  a { color:var(--accent); text-decoration:none; }
</style>
</head>
<body>
  <div id="wrap">
    <div id="topbar">
      <div id="stats">
        <span class="chip">ğŸŒ² Wood: <b id="wood">0</b></span>
        <span class="chip">ğŸª¨ Stone: <b id="stone">0</b></span>
        <span class="chip">ğŸ¥• Food: <b id="food">0</b></span>
        <span class="chip">ğŸª™ Coins: <b id="coins">0</b></span>
        <span class="chip">ğŸ‘¥ Pop: <b id="pop">0</b>/<b id="cap">0</b></span>
        <span class="chip">ğŸ˜Š Avg Happy: <b id="happy">100</b></span>
        <span class="chip">ğŸ•’ Day <b id="day">1</b> â€” <b id="clock">06:00</b></span>
      </div>
      <div class="chip" id="tip">Tip: Select a villager âœ set a job âœ place a building.</div>
    </div>

    <div id="canvasWrap">
      <canvas id="game" width="960" height="640"></canvas>
    </div>

    <div id="panel">
      <h3>Build</h3>
      <div class="row" id="buildRow"></div>
      <div class="small">Cost applies when construction completes. Builders work on placed blueprints.</div>
      <div class="sep"></div>

      <h3>Selected</h3>
      <div id="selectedInfo" class="small">None</div>
      <div class="row" id="jobsRow" style="margin-top:6px;"></div>
      <div class="sep"></div>

      <h3>Actions</h3>
      <div class="row">
        <button id="clearSel">Clear Selection (Esc)</button>
        <button id="centerCam">Center Camera (C)</button>
        <button id="speed1">â±ï¸ x1</button>
        <button id="speed2">â±ï¸ x2</button>
        <button id="speed3">â±ï¸ x4</button>
      </div>

      <div class="sep"></div>
      <h3>Legend</h3>
      <div class="small">
        <p>Tiles: ğŸŒ¿ Grass â€¢ ğŸŒ² Tree â€¢ ğŸª¨ Rock â€¢ ğŸŸ« Field â€¢ ğŸ  House â€¢ ğŸ­ Workshop â€¢ â›ï¸ Mine â€¢ ğŸ¬ Storage â€¢ ğŸ›’ Cart (visitor)</p>
        <p>Jobs: ğŸŸ© Farmer â€¢ ğŸŸ¦ Builder â€¢ ğŸŸ« Logger â€¢ â¬œ Miner â€¢ ğŸŸ¨ Carrier â€¢ ğŸŸ¥ Guard â€¢ â¬› Idle</p>
      </div>

      <div class="sep"></div>
      <div class="small">Keyboard: <b>1â€“6</b> build hotkeys â€¢ <b>Esc</b> clear â€¢ <b>C</b> center â€¢ <b>Space</b> pause â€¢ <b>R</b> rotate building (if rotatable)</div>
    </div>
  </div>

<script>
(() => {
  // ---------- World Setup ----------
  const TILE = 40;
  const W = 24, H = 16; // 960x640
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // UI refs
  const ui = {
    wood: document.getElementById('wood'),
    stone: document.getElementById('stone'),
    food: document.getElementById('food'),
    coins: document.getElementById('coins'),
    pop: document.getElementById('pop'),
    cap: document.getElementById('cap'),
    happy: document.getElementById('happy'),
    day: document.getElementById('day'),
    clock: document.getElementById('clock'),
    selectedInfo: document.getElementById('selectedInfo'),
    buildRow: document.getElementById('buildRow'),
    jobsRow: document.getElementById('jobsRow'),
    clearSel: document.getElementById('clearSel'),
    centerCam: document.getElementById('centerCam'),
    speed1: document.getElementById('speed1'),
    speed2: document.getElementById('speed2'),
    speed3: document.getElementById('speed3'),
    tip: document.getElementById('tip'),
  };

  // Camera
  const cam = { x:0, y:0, zoom:1 };

  // RNG
  const rand = (a,b)=>Math.random()*(b-a)+a|0;
  const clamp=(v,a,b)=>v<a?a:(v>b?b:v);
  const lerp=(a,b,t)=>a+(b-a)*t;

  // Tiles + map
  const T = {
    GRASS:0, TREE:1, ROCK:2, FIELD:3, HOUSE:4, WORKSHOP:5, MINE:6, STORAGE:7, CART:8, WATER:9, BLUEPRINT:10
  };
  const tileEmoji = { [T.GRASS]:"ğŸŒ¿", [T.TREE]:"ğŸŒ²", [T.ROCK]:"ğŸª¨", [T.FIELD]:"ğŸŸ«", [T.HOUSE]:"ğŸ ", [T.WORKSHOP]:"ğŸ­", [T.MINE]:"â›ï¸", [T.STORAGE]:"ğŸ¬", [T.CART]:"ğŸ›’", [T.WATER]:"ğŸ’§", [T.BLUEPRINT]:"ğŸ“" };

  const map = new Array(W*H).fill(T.GRASS);
  const buildProgress = {}; // key: i -> 0..1 for BLUEPRINT
  const idx=(x,y)=>y*W+x;
  const inb=(x,y)=>x>=0&&y>=0&&x<W&&y<H;

  // Scatter resources
  for (let i=0;i<W*H;i++){
    const x=i%W, y=(i/W)|0;
    if (x===0||y===0||x===W-1||y===H-1){ map[i]=T.WATER; continue; }
    const r=Math.random();
    if (r<0.08) map[i]=T.ROCK;
    else if (r<0.24) map[i]=T.TREE;
    else map[i]=T.GRASS;
  }

  // Resource pool
  const res = { wood:30, stone:20, food:10, coins:0 };

  // Time
  let day=1, time=6*60; // minutes since 00:00
  let speed=1, paused=false;

  // Villagers
  const JOB = { IDLE:'Idle', FARMER:'Farmer', BUILDER:'Builder', LOGGER:'Logger', MINER:'Miner', CARRIER:'Carrier', GUARD:'Guard' };
  const jobColor = { Idle:'#444', Farmer:'#1abc9c', Builder:'#3498db', Logger:'#8e5a2b', Miner:'#d7d7d7', Carrier:'#f1c40f', Guard:'#e74c3c' };
  const villagers = [];

  function makeVillager(x,y){
    return {
      x, y, fx:x, fy:y, moveTimer:0,
      job:JOB.IDLE, color:'#888',
      hunger:0, energy:1, happy:1, // 0..1
      target:null, carrying:null, name:randomName(),
    };
  }
  function randomName(){
    const A=['Blu','Gre','Red','Yel','Oran','Purp','Cya','Teal','Tau','Mag','Mint','Olive','Saff','Umbr'];
    const B=['bo','bi','by','do','di','dy','lo','li','ly','to','ti','ty'];
    return A[rand(0,A.length)]+B[rand(0,B.length)];
  }

  // Spawn start area
  function clearPatch(cx,cy,r=2){
    for(let y=cy-r;y<=cy+r;y++)for(let x=cx-r;x<=cx+r;x++){
      if(inb(x,y)) map[idx(x,y)]=T.GRASS;
    }
  }
  clearPatch((W/2)|0,(H/2)|0,3);
  const startX=(W/2)|0, startY=(H/2)|0;

  const buildings = {
    Field: { tile:T.FIELD, cost:{ wood:5 }, hotkey:'1', desc:'Grows food with a Farmer.' },
    House: { tile:T.HOUSE, cost:{ wood:10, stone:2 }, hotkey:'2', desc:'Housing +2 capacity.' },
    Workshop: { tile:T.WORKSHOP, cost:{ wood:12, stone:6 }, hotkey:'3', desc:'Boost build speed nearby.' },
    Mine: { tile:T.MINE, cost:{ wood:6, stone:8 }, hotkey:'4', desc:'Passive stone with a Miner.' },
    Storage: { tile:T.STORAGE, cost:{ wood:8, stone:2 }, hotkey:'5', desc:'+50 storage & delivery hub.' },
    CartPost: { tile:T.CART, cost:{ wood:5 }, hotkey:'6', desc:'Merchant stops here at dawn.', label:'Cart' },
  };
  const buildKeys = Object.keys(buildings);

  // Housing capacity
  const capacity = ()=>2 * countTiles(T.HOUSE);
  function countTiles(type){
    let c=0; for(let i=0;i<map.length;i++) if(map[i]===type) c++; return c;
  }

  // Start villagers
  for (let i=0;i<4;i++) villagers.push(makeVillager(startX+i%2, startY+(i/2|0)));

  // UI buttons
  let buildMode=null;
  function makeBuildButtons(){
    ui.buildRow.innerHTML='';
    for (const name of buildKeys){
      const b=document.createElement('button');
      const def=buildings[name];
      b.textContent = (def.label||name) + ` (${def.hotkey})`;
      b.title = def.desc + ' Cost: ' + Object.entries(def.cost).map(([k,v])=>`${k}:${v}`).join(' ');
      b.addEventListener('click', ()=>{ buildMode = (buildMode===name?null:name); refreshBuildSel(); });
      ui.buildRow.appendChild(b);
    }
    refreshBuildSel();
  }
  function refreshBuildSel(){
    [...ui.buildRow.children].forEach((btn,i)=>{
      btn.classList.toggle('sel', buildKeys[i]===buildMode);
    });
  }

  const jobs = [JOB.FARMER, JOB.BUILDER, JOB.LOGGER, JOB.MINER, JOB.CARRIER, JOB.GUARD, JOB.IDLE];
  function makeJobButtons(){
    ui.jobsRow.innerHTML='';
    for (const j of jobs){
      const b=document.createElement('button');
      b.textContent = j;
      b.style.borderColor = '#263041';
      b.addEventListener('click', ()=>{
        if (sel && sel.kind==='vill' && sel.ref){
          sel.ref.job = j;
          sel.ref.color = jobColor[j] || '#888';
        }
      });
      ui.jobsRow.appendChild(b);
    }
  }

  ui.clearSel.onclick=()=>{ sel=null; };
  ui.centerCam.onclick=()=>{ cam.x = startX*TILE - canvas.width/2 + TILE/2; cam.y = startY*TILE - canvas.height/2 + TILE/2; };
  ui.speed1.onclick=()=>speed=1;
  ui.speed2.onclick=()=>speed=2;
  ui.speed3.onclick=()=>speed=4;

  makeBuildButtons();
  makeJobButtons();

  // Selection
  let sel=null;

  // Input
  canvas.addEventListener('mousedown', (e)=>{
    const {gx,gy} = toGrid(e.offsetX, e.offsetY);
    if (!inb(gx,gy)) return;
    // If placing
    if (buildMode){
      placeBlueprint(gx,gy,buildMode);
      return;
    }
    // Try pick villager
    const hit = villagers.find(v=>v.x===gx && v.y===gy);
    if (hit){ sel={ kind:'vill', ref:hit }; return; }
    // Otherwise select tile
    sel={ kind:'tile', x:gx, y:gy, tile: map[idx(gx,gy)] };
  });

  window.addEventListener('keydown',(e)=>{
    if (e.key==='Escape'){ sel=null; buildMode=null; refreshBuildSel(); }
    if (e.key.toLowerCase()==='c'){ ui.centerCam.click(); }
    if (e.key===' '){ paused=!paused; e.preventDefault(); }
    // build hotkeys
    for (const name of buildKeys){
      if (e.key===buildings[name].hotkey){ buildMode = (buildMode===name?null:name); refreshBuildSel(); }
    }
  });

  // Helpers
  function toGrid(px,py){
    const x = Math.floor((px + cam.x)/TILE);
    const y = Math.floor((py + cam.y)/TILE);
    return { gx:x, gy:y };
  }

  function canBuildAt(x,y){
    const t = map[idx(x,y)];
    return (t===T.GRASS || t===T.TREE || t===T.ROCK);
  }

  function placeBlueprint(x,y,name){
    if (!canBuildAt(x,y)) return;
    const i = idx(x,y);
    map[i]=T.BLUEPRINT;
    buildProgress[i]={ name, p:0 };
  }

  // --- Economy modifiers
  function applyCost(cost){
    for (const k in cost){ res[k]-=cost[k]; }
  }
  function canAfford(cost){
    for (const k in cost){ if ((res[k]||0)<cost[k]) return false; }
    return true;
  }

  // --- Sim loop
  let acc=0, last=performance.now();
  function tick(dt){
    // Time
    if (!paused){
      time += dt * 0.005 * speed; // minutes
      if (time>=24*60){ time -= 24*60; day++; dawnEvents(); }
    }

    // Builders progress blueprints
    for (const i in buildProgress){
      const bp = buildProgress[i];
      const x=i%W|0, y=(i/W)|0;
      // boost near workshop
      const hasWS = neighbors(x,y).some(([nx,ny])=>map[idx(nx,ny)]===T.WORKSHOP);
      const baseRate = 0.0015 * speed * (hasWS?1.6:1);
      // if any builder is adjacent, speed up a lot
      const adjBuilders = villagers.filter(v=>v.job===JOB.BUILDER && Math.abs(v.x-x)+Math.abs(v.y-y)===1).length;
      const rate = baseRate * (adjBuilders? (2.5+0.4*adjBuilders) : 0.4);
      if (!paused) bp.p = Math.min(1, bp.p + rate);
      if (bp.p>=1){
        const def = buildings[bp.name];
        if (canAfford(def.cost)){
          applyCost(def.cost);
          map[i] = def.tile;
        } else {
          // leave blueprint if cannot pay yet
          bp.p = 0.97; // hover just below complete
        }
        if (map[i]!==T.BLUEPRINT) delete buildProgress[i];
      }
    }

    // Villagers AI
    for (const v of villagers){
      doNeeds(v, dt);
      doJob(v, dt);
      moveVillager(v, dt);
    }

    // Passive production
    passiveProduction(dt);

    // UI
    updateUI();
  }

  function neighbors(x,y){
    return [[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(([a,b])=>inb(a,b));
  }

  function doNeeds(v,dt){
    if (paused) return;
    // hunger grows over day; eat at night
    v.hunger = clamp(v.hunger + dt*0.00004*speed, 0, 1.2);
    // energy drops while moving
    const moving = (Math.abs(v.fx - v.x) + Math.abs(v.fy - v.y))>0;
    v.energy = clamp(v.energy - (moving? dt*0.00006*speed : dt*0.00002*speed), 0, 1);
    // happiness from energy + hunger
    v.happy = clamp( 0.5*(1-v.hunger) + 0.5*v.energy, 0, 1);
  }

  function dawnEvents(){
    // Night consumption
    const need = villagers.length;
    if (res.food >= need){
      res.food -= need;
      // rest
      for (const v of villagers){ v.hunger = Math.max(0, v.hunger-0.5); v.energy = Math.min(1, v.energy+0.6); }
      ui.tip.textContent = "A new day dawns. Everyone ate and rested.";
    } else {
      const deficit = need - res.food;
      res.food = 0;
      for (let i=0;i<villagers.length;i++){
        const v=villagers[i];
        if (i<deficit){ v.hunger = Math.min(1.2, v.hunger+0.4); v.energy = Math.max(0, v.energy-0.2); }
        else { v.energy = Math.min(1, v.energy+0.3); }
      }
      ui.tip.textContent = "Food ran short last night. Morale slipped!";
    }

    // Merchant visit if Cart exists
    if (countTiles(T.CART)>0){
      // simple trade: convert 10 wood -> 4 coins, 10 stone -> 5 coins, 10 food -> 6 coins
      let trades=0;
      while(res.wood>=10){ res.wood-=10; res.coins+=4; trades++; if (trades>6) break; }
      while(res.stone>=10){ res.stone-=10; res.coins+=5; trades++; if (trades>6) break; }
      while(res.food>=10){ res.food-=10; res.coins+=6; trades++; if (trades>6) break; }
      if (trades>0) ui.tip.textContent = `Merchant traded ${trades} bundles for coins.`;
    }

    // Try add new villager if housing
    const cap = capacity();
    if (villagers.length<cap){
      villagers.push(makeVillager(startX, startY));
      ui.tip.textContent += ` New villager arrived!`;
    }
  }

  function passiveProduction(dt){
    if (paused) return;
    // Farmers near fields tick food
    const farmerTiles = new Set(villagers.filter(v=>v.job===JOB.FARMER).map(v=>idx(v.x,v.y)));
    if (farmerTiles.size){
      // Any FIELD adjacent to a farmer tile slowly grows food
      let growth = 0;
      farmerTiles.forEach(i=>{
        const x=i%W|0, y=(i/W)|0;
        neighbors(x,y).forEach(([nx,ny])=>{
          if (map[idx(nx,ny)]===T.FIELD) growth++;
        });
      });
      res.food += growth * 0.003 * speed;
    }
    // Miner on Mine
    villagers.forEach(v=>{
      if (v.job===JOB.MINER){
        if (map[idx(v.x,v.y)]===T.MINE) res.stone += 0.006 * speed;
        // if on ROCK directly, slower
        if (map[idx(v.x,v.y)]===T.ROCK) res.stone += 0.003 * speed;
      }
      if (v.job===JOB.LOGGER){
        // logger adjacent to TREE: periodically chop and convert the tree to grass
        const trees = neighbors(v.x,v.y).filter(([nx,ny])=>map[idx(nx,ny)]===T.TREE);
        if (trees.length && Math.random()<0.003*speed){
          const [nx,ny]=trees[rand(0,trees.length)];
          map[idx(nx,ny)]=T.GRASS;
          res.wood += 3;
        }
      }
    });
  }

  function doJob(v,dt){
    if (paused) return;

    // Targeting:
    if (!v.target){
      if (v.job===JOB.LOGGER){
        // go to nearest tree neighbor tile
        v.target = findAdjTo(T.TREE, v.x, v.y);
      } else if (v.job===JOB.MINER){
        v.target = findAnyOf([T.MINE, T.ROCK], v.x, v.y);
      } else if (v.job===JOB.BUILDER){
        v.target = findBlueprint(v.x, v.y);
      } else if (v.job===JOB.FARMER){
        v.target = findAdjTo(T.FIELD, v.x, v.y);
      } else if (v.job===JOB.CARRIER){
        // wander between storage and production sites
        v.target = findAnyOf([T.STORAGE, T.FIELD, T.MINE], v.x, v.y);
      } else if (v.job===JOB.GUARD){
        // hang near houses
        v.target = findAnyOf([T.HOUSE], v.x, v.y);
      }
    }

    // Light job effects when at target
    if (v.target && v.x===v.target.x && v.y===v.target.y){
      if (v.job===JOB.BUILDER){
        // being adjacent handled in blueprint loop
        v.target = null;
      } else if (v.job===JOB.CARRIER){
        // convert resources slightly (pretend deliveries)
        if (Math.random()<0.002*speed) res.food += 0.5;
        v.target = null;
      } else if (v.job===JOB.GUARD){
        // small global happiness boost
        if (Math.random()<0.0015*speed) villagers.forEach(u=>u.happy = clamp(u.happy+0.02,0,1));
        if (Math.random()<0.01) v.target=null;
      } else {
        if (Math.random()<0.01) v.target=null;
      }
    }
  }

  function moveVillager(v,dt){
    if (paused) return;
    v.moveTimer -= dt;
    if (v.moveTimer>0) return;
    v.moveTimer = 80 / (1 + 0.8*v.happy); // happier = faster
    if (!v.target){ // random tiny roam
      const dirs = neighbors(v.x,v.y).filter(([nx,ny])=>map[idx(nx,ny)]!==T.WATER);
      if (dirs.length && Math.random()<0.2) [v.fx,v.fy] = dirs[rand(0,dirs.length)];
    } else {
      // greedy step toward target
      const dx = Math.sign(v.target.x - v.x);
      const dy = Math.sign(v.target.y - v.y);
      const opts = [];
      if (dx!==0) opts.push([v.x+dx, v.y]);
      if (dy!==0) opts.push([v.x, v.y+dy]);
      if (!opts.length) opts.push([v.x,v.y]);
      const step = opts[rand(0,opts.length)];
      if (inb(step[0],step[1]) && map[idx(step[0],step[1])]!=T.WATER){
        [v.fx,v.fy] = step;
      }
      if (v.fx===v.x && v.fy===v.y && Math.random()<0.3) v.target=null; // stuck escape
    }
    v.x=v.fx; v.y=v.fy;
  }

  function findAnyOf(types,x,y){
    let best=null, bestD=1e9;
    for (let yy=0;yy<H;yy++) for (let xx=0;xx<W;xx++){
      const t = map[idx(xx,yy)];
      if (types.includes(t)){
        const d = Math.abs(xx-x)+Math.abs(yy-y);
        if (d<bestD){ bestD=d; best={x:xx,y:yy}; }
      }
    }
    return best;
  }
  function findAdjTo(type,x,y){
    let best=null, bestD=1e9;
    for (let yy=0;yy<H;yy++) for (let xx=0;xx<W;xx++){
      if (map[idx(xx,yy)]===type){
        // pick a neighbor tile that isn't water
        const opts = neighbors(xx,yy).filter(([nx,ny])=>map[idx(nx,ny)]!==T.WATER);
        for (const [nx,ny] of opts){
          const d=Math.abs(nx-x)+Math.abs(ny-y);
          if (d<bestD){ bestD=d; best={x:nx,y:ny}; }
        }
      }
    }
    return best;
  }
  function findBlueprint(x,y){
    let best=null, bestD=1e9;
    for (const i in buildProgress){
      const xx=i%W|0, yy=(i/W)|0;
      const d=Math.abs(xx-x)+Math.abs(yy-y);
      if (d<bestD){ bestD=d; best={x:xx,y:yy}; }
    }
    return best;
  }

  // ---------- Rendering ----------
  function draw(){
    ctx.save();
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.translate(-cam.x, -cam.y);

    // Day/Night tint
    const t = (time%(24*60))/(24*60);
    const night = Math.cos((t-0.25)*Math.PI*2)*0.5+0.5; // 0..1, 1 is noon
    const sky = lerp(0.15, 0.5, night);
    ctx.fillStyle = `hsl(210, 30%, ${sky*30+5}%)`;
    ctx.fillRect(cam.x, cam.y, canvas.width, canvas.height);

    // Grid tiles
    for (let y=0;y<H;y++){
      for (let x=0;x<W;x++){
        const i=idx(x,y);
        const t = map[i];
        const px=x*TILE, py=y*TILE;
        // base
        ctx.fillStyle = (t===T.WATER)?'#0a4460':'#0e1a22';
        if (t!==T.WATER) ctx.fillStyle = '#0f151b';
        ctx.fillRect(px,py,TILE,TILE);
        // content shading
        if (t===T.GRASS) { ctx.fillStyle='#0f1f2a'; ctx.fillRect(px+4,py+4,TILE-8,TILE-8); }
        if (t===T.TREE){ drawTree(px,py); }
        if (t===T.ROCK){ drawRock(px,py); }
        if (t===T.FIELD){ drawField(px,py); }
        if (t===T.HOUSE){ drawHouse(px,py); }
        if (t===T.WORKSHOP){ drawWorkshop(px,py); }
        if (t===T.MINE){ drawMine(px,py); }
        if (t===T.STORAGE){ drawStorage(px,py); }
        if (t===T.CART){ drawCart(px,py); }
        if (t===T.BLUEPRINT){ drawBlueprint(px,py, buildProgress[i]); }

        // grid line
        ctx.strokeStyle='rgba(255,255,255,0.04)';
        ctx.strokeRect(px,py,TILE,TILE);
      }
    }

    // Villagers
    for (const v of villagers){
      drawVillager(v);
    }

    // Selection highlight
    if (sel){
      ctx.lineWidth=2;
      ctx.strokeStyle='rgba(111,211,168,0.9)';
      if (sel.kind==='vill'){ rectStroke(sel.ref.x*TILE, sel.ref.y*TILE, TILE, TILE); }
      else if (sel.kind==='tile'){ rectStroke(sel.x*TILE, sel.y*TILE, TILE, TILE); }
    }

    ctx.restore();
  }

  function rectStroke(x,y,w,h){
    ctx.strokeRect(x+2,y+2,w-4,h-4);
  }
  function drawTree(px,py){
    ctx.fillStyle='#184c28'; ctx.fillRect(px+8,py+8,24,24);
    ctx.fillStyle='#0d2a15'; ctx.fillRect(px+16,py+24,8,8);
  }
  function drawRock(px,py){
    ctx.fillStyle='#6f7c88'; ctx.fillRect(px+10,py+12,20,16);
    ctx.fillStyle='#8e9aa6'; ctx.fillRect(px+14,py+12,6,4);
  }
  function drawField(px,py){
    ctx.fillStyle='#5b3b20'; ctx.fillRect(px+4,py+4,32,32);
    ctx.fillStyle='#8a5e2a'; for(let i=0;i<4;i++) ctx.fillRect(px+6,py+6+i*8,28,2);
    ctx.fillStyle='#a3c95f'; for(let i=0;i<3;i++) ctx.fillRect(px+10+i*8,py+10,2,20);
  }
  function drawHouse(px,py){
    ctx.fillStyle='#2b3f5a'; ctx.fillRect(px+6,py+14,28,22);
    ctx.fillStyle='#8f4b2e'; ctx.fillRect(px+4,py+8,32,10);
    ctx.fillStyle='#c9d6e2'; ctx.fillRect(px+22,py+20,8,8);
    ctx.fillStyle='#442b18'; ctx.fillRect(px+10,py+22,6,10);
  }
  function drawWorkshop(px,py){
    ctx.fillStyle='#3b3b4a'; ctx.fillRect(px+6,py+10,28,26);
    ctx.fillStyle='#9aa3b0'; ctx.fillRect(px+6,py+10,28,6);
    ctx.fillStyle='#d0b07a'; ctx.fillRect(px+14,py+22,12,6);
  }
  function drawMine(px,py){
    ctx.fillStyle='#2a2f35'; ctx.fillRect(px+6,py+8,28,28);
    ctx.fillStyle='#444'; ctx.fillRect(px+10,py+18,20,10);
    ctx.fillStyle='#7f8c99'; ctx.fillRect(px+14,py+18,12,10);
  }
  function drawStorage(px,py){
    ctx.fillStyle='#5a432e'; ctx.fillRect(px+6,py+10,28,24);
    ctx.fillStyle='#a67c52'; ctx.fillRect(px+6,py+10,28,4);
    ctx.fillStyle='#caa57a'; ctx.fillRect(px+12,py+18,4,10);
    ctx.fillRect(px+24,py+18,4,10);
  }
  function drawCart(px,py){
    ctx.fillStyle='#7a5332'; ctx.fillRect(px+6,py+14,28,16);
    ctx.fillStyle='#2d2d2d'; ctx.fillRect(px+10,py+30,8,6);
    ctx.fillRect(px+24,py+30,8,6);
  }
  function drawBlueprint(px,py,bp){
    ctx.strokeStyle='rgba(87,170,255,0.8)';
    ctx.strokeRect(px+6,py+6,28,28);
    ctx.fillStyle='rgba(87,170,255,0.15)';
    ctx.fillRect(px+6,py+6,28*(bp?.p||0),28);
  }

  function drawVillager(v){
    const px=v.x*TILE, py=v.y*TILE;
    // body square
    ctx.fillStyle=v.color || '#999';
    ctx.fillRect(px+10,py+10,20,20);
    // eyes : two dots
    ctx.fillStyle='#000';
    const tired = (1-v.energy)*2;
    const ex1=px+15, ex2=px+25, ey=py+18;
    ctx.beginPath(); ctx.arc(ex1,ey,2,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(ex2,ey,2,0,Math.PI*2); ctx.fill();
    if (tired>0.8){ // half lids
      ctx.strokeStyle='#333'; ctx.beginPath(); ctx.moveTo(ex1-2,ey); ctx.lineTo(ex1+2,ey); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(ex2-2,ey); ctx.lineTo(ex2+2,ey); ctx.stroke();
    }
    // name tag
    ctx.fillStyle='rgba(255,255,255,0.7)';
    ctx.font='10px system-ui';
    ctx.fillText(v.name, px+8, py+9);
  }

  function updateUI(){
    ui.wood.textContent = Math.floor(res.wood);
    ui.stone.textContent = Math.floor(res.stone);
    ui.food.textContent = Math.floor(res.food);
    ui.coins.textContent = Math.floor(res.coins);
    ui.pop.textContent = villagers.length;
    ui.cap.textContent = capacity();
    const avg = villagers.reduce((a,v)=>a+v.happy,0)/villagers.length || 1;
    ui.happy.textContent = Math.round(avg*100);
    ui.day.textContent = day;
    const hh = Math.floor(time/60)%24, mm = Math.floor(time%60);
    ui.clock.textContent = `${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}`;
    // selected info
    if (!sel){ ui.selectedInfo.textContent='None'; return; }
    if (sel.kind==='vill'){
      const v=sel.ref;
      ui.selectedInfo.innerHTML =
        `Name: <b>${v.name}</b> &nbsp; Job: <b style="color:${jobColor[v.job]||'#ccc'}">${v.job}</b><br>`+
        `Energy: ${(v.energy*100|0)}% &nbsp; Hunger: ${(v.hunger*100|0)}% &nbsp; Happy: ${(v.happy*100|0)}%<br>`+
        `Pos: (${v.x}, ${v.y})`;
    } else {
      const i = idx(sel.x, sel.y);
      let txt = `Tile: <b>${tileEmoji[map[i]]||'?'}</b> `;
      if (map[i]===T.BLUEPRINT){
        const bp = buildProgress[i]; const def = buildings[bp.name];
        txt += `Blueprint of <b>${bp.name}</b> ${(bp.p*100|0)}% &nbsp; Cost: `
          + Object.entries(def.cost).map(([k,v])=>`${k}:${v}`).join(', ');
      }
      ui.selectedInfo.innerHTML = txt+` &nbsp;@ (${sel.x},${sel.y})`;
    }
  }

  // ---------- Game loop ----------
  function frame(t){
    const dt = Math.min(50, t-last); last=t;
    acc += dt;
    while (acc>=16){
      tick(16);
      acc-=16;
    }
    draw();
    requestAnimationFrame(frame);
  }

  // Start
  ui.centerCam.click();
  requestAnimationFrame(frame);

  // ---------- Build interactions ----------
  function completeImmediatelyForTesting(){/* hook if needed */}
  // ---------- Utility end ----------

})();
</script>
</body>
</html>
